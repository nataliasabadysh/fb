# Redux + React ❤️
react - redux 


# connet 
- HOC 
- connet делает автоматически store.dispatch 
- привязывает любой React-компонент(к пропсам) - с Redux store(State)
- В результате получаем готовые вызовы action
- UI всегда синхронизирован с состоянием


Redux работает в синхронном режиме.
Запуск и обработка reducer'ами каждого action выполнится последовательно

# Provader 
- Вершина иерархии приложения 
- Оборачивает все приложение
- Открывает доступ к store для conneсt

- Поэтому conneсt получает доступ для всего приложения с любой точки

* обертка для всего приложения 
* открывает канал conneсt и вкладывает redux-store 
* получаем доступ чтения из него на любой вложенности

import { Provider } from 'react-redux';
import { store } from './init/store';

    <Provider store = { store }>
        <Route>
            <App />
        </Route>
    </Provider>

<hr />
<h2>И так </h2>
Redux - синхронный по-умолчанию.✅
Основан на чистых фун-ях и имутабельных структур данных ✅

# Redux Middleware  
Для ассинхронных операций 
сайд-эфекты  и другие потоки данных

Redux Middleware - подключаеться в синхронный поток данных Redux и по средствам фун-и перехватчика поймает фун-и action -

# UI

- Синхронный поток данных 
<h2>onClick -> action -> reducer -> store - re-render--> UI</h2>

- Ассинхронный поток данных 
<h2>onClick -> action -> MIDDLEWARE -> reducer -> store - re-render  --> UI</h2>


* MIDDLEWARE 
- перехватывает синхронный поток и пропуская через себя все action 
- перехватывает action - obj 
- выполняет ассинхронный операции - API 
- передает action на обработку в reducer (или последний если их много передает reducer )
- он слушает нужный action ( fetchSomething ) и начинает выполнять асинхронный запрос на получение данных <b> паралельно</b> 
- он не блокирует поток данных Redux


# MIDDLEWARE
- можно просто заблокировать action что бы он не дошел до reducer 
- может новый запустить синхронный action , 
положыв данные в payload и отправить этот action - reducer на обработку 

- js фун-и 
- стают в цепочку на асинхронное выполнение chaning

- может быть любое количество MIDDLEWARE между action reducer в одном выхове - станут в цепочку 


# Redux  есть  MIDDLEWARE чего нет во FLUX 

